GraphQL(Graph Query Language)
---
GraphQL은 페이스북이 2012년에 개발하여 2015년에 공개적으로 발표한 데이터 질의어이다.

기존 ``REST API``에 비해 클라이언트와 서버 간의 데이터 교환과 관련된 몇 가지 문제를 해결하고자 개발되었다.

### 주요 특징과 작동 방식
1. **유연한 데이터 요청**: 클라이언트는 필요한 데이터의 구체적인 필드와 구조를 지정하여 서버에 요청한다. 이로써 필요한 데이터만 가져올 수 있으며, 과도한 데이터 오버페칭이나 여러 요청을 보내야 하는 문제를 해결한다.

2. **단일 엔드포인트**: GraphQL은 단일 엔드포인트를 사용하며, 여러 REST 엔드포인트 대신 하나의 GraphQL 엔드포인트로 모든 데이터 요청을 처리할 수 있다.

3. **타입 시스템**: GraphQL은 데이터 모델을 타입으로 정의하고, 각 타입에 해당하는 필드를 정의한다. 이를 통해 데이터의 구조와 유형을 명확하게 정의할 수 있다.

4. **리졸버 함수**: 클라이언트의 쿼리에 대응하는 서버 측 리졸버 함수를 정의한다. 리졸버 함수는 데이터를 실제로 가져오거나 조작하는 로직을 구현한다.

    리졸버 함수는 데이터 가져오기, 관계 해석, 필드 계산, 인증 및 권한 부여 등의 역할을 한다.

5. **실시간 데이터**: GraphQL은 Subscriptions을 통해 실시간 데이터 업데이트를 제공할 수 있다. 이로써 웹 소켓을 사용하여 실시간 시능을 구현할 수 있다.

6. **자동 문서화**: GraphQL 스키마를 기반으로 자동으로 API 문서를 생성할 수 있다.

7. **필드별 인증 및 권한 부여**: 필드 수준에서 인증과 권한 부여를 구현할 수 있어 세밀한 접근 제어가 가능하다.

### REST API와의 차이점
1. **데이터 요청 방식**
    - GraphQL: ``클라이언트가 필요한 데이터를 명시적으로 요청``한다. 클라이언트가 필요한 필드와 구조를 지정하여 ``단일 쿼리``를 보내며, ``불필요한 데이터를 가져오지 않는다``.
    - REST API: 클라이언트가 ``사전 정의된 엔드포인트에 요청``을 보내며, 서버에서 ``정의한 데이터를 응답``으로 받는다. 각 엔드포인트는 특정 데이터를 반환하며 ``필요한 데이터를 얻기 위해 여러 번의 요청이 필요할 수 있다``.

<br>

2. **오버페칭과 언더페칭**
    - GraphQL: 클라이언트가 필요한 데이터를 명시적으로 지정하므로 ``오버페칭``(불필요한 데이터 가져오기)이 ``발생하지 않는다``. 반면, ``언더페칭``(필요한 데이터 누락) 문제가 발생할 가능성이 있다.
    - REST API: 특정 엔드포인트는 정해진 데이터를 반환하므로 ``오버페칭이나 언더페칭 문제가 발생할 수 있다``.

<br>

3. **단일 엔드포인트 vs 다중 엔드포인트**
    - GraphQL: ``단일 엔드포인트``를 사용하여 모든 데이터 요청을 처리한다.
        - 게시물 쿼리 엔드포인트: /graphql
        - 게시물 쿼리 요청:
            ```
            query {
                posts {
                    title
                    content
                }
            }
            ```
        - 특정 게시물 쿼리 엔드포인트: /graphql
        - 특정 게시물 처리 요청:
            ```
            query {
                post(id: 123) {
                    title
                    content
                }
            }
            ```
    - REST API: ``여러 개의 엔드포인트``를 사용하여 각 엔드포인트는 특정 데이터나 기능을 나타낸다.
        - 모든 게시물 가져오기 엔드포인트: /posts
        - 모든 게시물 가져오기 요청: GET /posts
        - 특정 게시물 가져오기 엔드포인트: /posts/{post_id}
        - 특정 게시물 가져오기 요청: GET /posts/123

<br>

4. **버전 관리**
    - GraphQL: ``엔드포인트가 하나``이므로 새로운 필드나 기능을 추가하더라도 ``기존 쿼리에 영향을 주지 않는다``.
    - REST API: 새로운 기능을 추가하거나 업데이트할 때 ``버전 관리가 필요한 경우가 있다``.

<br>

5. **응답 크기**
    - GraphQL: ``클라이언트가 필요한 데이터만 요청``하므로 ``응답 크기를 최소화``할 수 있다.
    - REST API: 서버에서 미리 정의한 데이터를 반환하므로 ``클라이언트가 필요하지 않은 데이터를 받을 수 있어 응답 크기가 크게 될 수 있다``.

### GraphQL의 장점
1. **유연한 데이터 요청**: 클라이언트가 필요한 데이터를 명시적으로 요청할 수 있다. 이로써 필요한 데이터만 가져오고 불필요한 데이터를 제거함으로써 데이터 효율성을 높일 수 있다.
2. **단일 엔드포인트**: GraphQL은 단일 엔드포인트를 사용하여 모든 데이터 요청을 처리한다. 이를 통해 엔드포인트 관리와 API 버전 관리가 간단해지며, 여러 엔드포인트에 대한 오버헤드를 줄일 수 있다.
3. **오버페칭과 언더페칭 문제 해결**: 클라이언트가 필요한 데이터를 명시적으로 요청하므로 오버페칭(불필요한 데이터 가져오기)과 언더페칭(필요한 데이터 누락) 문제를 효과적으로 해결할 수 있다.
4. **타입 시스템**: GraphQL은 데이터 모델을 타입으로 정의하고, 각 필드에 대한 타입을 명시한다. 이로써 데이터 구조와 유형을 명확하게 정의할 수 있다.
5. **강력한 인트로스펙션(Introspection)**: GraphQL은 스키마에 대한 자동 인트로스펙션을 제공하여 클라이언트가 서버의 데이터 모델과 쿼리 가능한 필드 등에 대한 정보를 동적으로 얻을 수 있다.
6. **한 번의 요청으로 다양한 데이터 가져오기**: 여러 종류의 데이터를 한 번의 요청으로 가져올 수 있다. 여러 객체나 관계를 한 번에 처리하며, 여러 API 호출을 줄여준다.
7. **실시간 데이터 처리**: GraphQL은 Subscriptions를 통해 실시간 데이터 업데이트를 제공할 수 있다. 이로써 웹 소켓을 사용하여 실시간 기능을 구현할 수 있다.
8. **클라이언트 측 캐싱**: 클라이언트가 필요한 데이터만 요청하고 응답받으므로 클라이언트 측에서 캐싱을 더욱 효율적으로 수행할 수 있다.
9. **인증 및 권한 부여**: 필드 수준에서 인증과 권한 부여를 구현할 수 있어 세밀한 접근 제어가 가능하다.


### GraphQL의 단점
1. **쿼리 복잡성**: 유연성을 가진 GraphQL은 쿼리가 복잡해질 수 있다.
2. **과도한 요청**: 클라이언트가 필요한 데이터를 명시적으로 요청하므로, 클라이언트 개발자가 데이터 모델을 잘 이해하고 적절한 요청을 작성해야 한다. 필요한 데이터를 모두 요청하지 않으면 언더페칭 문제가 발생할 수 있다.
3. **보안 문제**: 필드 수준에서의 인증 및 권한 부여는 강력하지만, 실수로 필드를 노출시키거나 권한 설정을 놓칠 가능성이 있다.
4. **쿼리 정리 문제**: GraphQL에서 모든 요청에 사용된 필드와 구조가 정확하게 문서화되지 않으면 클라이언트 개발자가 필요한 데이터를 이해하는 데 어려움을 겪을 수 있다.
5. **오버헤드**: 일부 상황에서는 작은 규모의 프로젝트에서는 REST API보다 GraphQL이 더 많은 오버헤드를 가질 수 있다. 특히 데이터를 읽을 때 비슷한 REST 엔드포인트 대신에 GraphQL을 사용할 때다.
6. **캐싱 어려움**: 클라이언트가 필요한 데이터를 명시적으로 지정하기 때문에 서버에서 클라이언트의 데이터 요구를 예측하기 어려워 캐싱이 복잡해질 수 있다.
7. **현존하지 않는 REST의 기능**: GraphQL은 모든 API의 기능을 대체하지 못한다. 특정 REST API가 제공하는 기능이 필요한 경우에는 GraphQL을 사용할 수 없을 수 있다.
